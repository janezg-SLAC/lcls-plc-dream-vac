<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_VentMcCat" Id="{755fdd9e-2599-4b57-ba01-fef530ec2196}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_VentMcCat EXTENDS FB_Operation
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
    fRough2VFV2Position : REAL;
    fRough2VFV3Position : REAL;
END_VAR
VAR CONSTANT
    VFV_MAX_POSITION : INT := 100;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[SUPER^(iq_sMessageBuffer := iq_sMessageBuffer);

CASE eStep OF
E_OpStep.IDLE: // Do nothing

E_OpStep.START: // Close beamline window valves //Defer cancel if this procedure should not be cancelled from user!
    //Close window beamline valves
    bCLOSE_TMO_MR5K4_VWC := TRUE;
    bCLOSE_TMO_TM2K4_VWC := TRUE;
    M_SetMessage('Closing TMO window valves');
    M_RunTimeoutTimer(VALVE_TIMEOUT);

    IF (bTMO_MR5K4_VWC_CLOSED_LS AND bTMO_TM2K4_VWC_CLOSED_LS) THEN
        M_SetMessage('Window valves closed');
        M_ResetTimeoutTimer();
        E_OpStep := E_OpStep.VMCAS_CLOSE_ISOLATION_VALVES;
    ELSIF M_TimeoutExpired() THEN
        M_SetMessage('Closing window valve - timeout');
        M_ResetTimeoutTimer();
        E_OpStep := E_OpStep.VMCAS_CLOSE_ISOLATION_VALVES;
    END_IF

E_OpStep.VMCAS_CLOSE_ISOLATION_VALVES: // Close isolation valves (DP1:VRC:01, CAT1:VRC:01), Bypas valve DP1:VRC:01 shall open
    DREAM_DP1_VRC_01.M_Set_OPN_SW(FALSE);
    DREAM_CAT1_VRC_01.M_Set_OPN_SW(FALSE);
    M_SetMessage('Close Isolation valves');
    M_RunTimeoutTimer(VALVE_TIMEOUT);

    IF DREAM_DP1_VRC_01.iq_stValve.i_xClsLS AND DREAM_CAT1_VRC_01.iq_stValve.i_xClsLS AND DREAM_DP1_VRC_02.iq_stValve.i_xOpnLS THEN
        M_SetMessage('Isolation valves closed, bypass open');
        M_ResetTimeoutTimer();
        E_OpStep := E_OpStep.VMCAS_STOP_TURBO_PUMPS;
    ELSIF M_TimeoutExpired() THEN
        M_FatalError('Moving isolation,bypass valves-timeout');
    END_IF

E_OpStep.VMCAS_STOP_TURBO_PUMPS: // Stop MC and CAT Turbo pumps
    DREAM_DP1_PTM_01.M_Run(FALSE);
    DREAM_DP2_PTM_01.M_Run(FALSE);
    DREAM_DP3_PTM_01.M_Run(FALSE);
    DREAM_MC_PTM_01.M_Run(FALSE);
    DREAM_MC_PTM_02.M_Run(FALSE);
    DREAM_CAT1_PTM_01.M_Run(FALSE);
    DREAM_CAT2_PTM_01.M_Run(FALSE);
    DREAM_ROUGH2_PTM_01.M_Run(FALSE);
    DREAM_ROUGH2_PTM_02.M_Run(FALSE);

    M_SetMessage('Stopping MC and CAT turbos');
    E_OpStep := E_OpStep.VMCAS_CLOSE_ROUGH_VALVES;

E_OpStep.VMCAS_CLOSE_ROUGH_VALVES: // Close roughing valves
    DREAM_ROUGH2_VRC_01.M_Set_OPN_SW(FALSE);
    DREAM_ROUGH2_VRC_02.M_Set_OPN_SW(FALSE);
    M_SetMessage('Close Roughing valves');
    M_RunTimeoutTimer(VALVE_TIMEOUT);

    IF DREAM_ROUGH2_VRC_01.iq_stValve.i_xClsLS AND DREAM_ROUGH2_VRC_02.iq_stValve.i_xClsLS THEN
        M_SetMessage('Roughing valves closed');
        M_ResetTimeoutTimer();
        E_OpStep := E_OpStep.VMCAS_STOP_GAUGES;
    ELSIF M_TimeoutExpired() THEN
        M_FatalError('Moving roughing valves-timeout');
    END_IF

E_OpStep.VMCAS_STOP_GAUGES: // Turn off gauges
    DREAM_DP1_GHC_01.M_HVE(FALSE);
    DREAM_DP2_GHC_01.M_HVE(FALSE);
    DREAM_DP3_GHC_01.M_HVE(FALSE);
    DREAM_MC_GHC.M_HVECh1(FALSE);
    DREAM_MC_GHC.M_HVECh2(FALSE);
    DREAM_CAT1_GHC_01.M_HVE(FALSE);
    DREAM_CAT2_GHC_01.M_HVE(FALSE);

    M_SetMessage('Turning OFF MC and CAT Gauges');
    E_OpStep := E_OpStep.VMCAS_WAIT_FOR_TURBO_PUMPS_SPIN_DOWN;

E_OpStep.VMCAS_WAIT_FOR_TURBO_PUMPS_SPIN_DOWN: // Turbos need to spin down to below 100 before start venting procedure
    M_RunTimeoutTimer(TURBOS_SPINDOWN_TIMEOUT);
    M_SetMessage('Waiting for pumps to spindown');

    //How should we mitigate if serial communication work?
    IF DREAM_DP1_PTM_01.iq_stPTM.i_diCurSpd < 100
        AND DREAM_DP2_PTM_01.iq_stPTM.i_diCurSpd < 100
        AND DREAM_DP3_PTM_01.iq_stPTM.i_diCurSpd < 100
        AND DREAM_MC_PTM_01.iq_stPTM.i_diCurSpd < 100
        AND DREAM_MC_PTM_02.iq_stPTM.i_diCurSpd < 100
        AND DREAM_CAT1_PTM_01.iq_stPTM.i_diCurSpd < 100
        AND DREAM_CAT2_PTM_01.iq_stPTM.i_diCurSpd < 100
        AND DREAM_ROUGH2_PTM_01.iq_stPTM.i_diCurSpd < 100
        AND DREAM_ROUGH2_PTM_02.iq_stPTM.i_diCurSpd < 100
    THEN
        M_SetMessage('Pumps below 100 Hz, start venting');
        M_ResetTimeoutTimer();
        E_OpStep := E_OpStep.VMCAS_VENTING;
    ELSIF M_TimeoutExpired()
        AND NOT DREAM_DP1_PTM_01.iq_stPTM.i_xAtSpd
        AND NOT DREAM_DP2_PTM_01.iq_stPTM.i_xAtSpd
        AND NOT DREAM_DP3_PTM_01.iq_stPTM.i_xAtSpd
        AND NOT DREAM_MC_PTM_01.iq_stPTM.i_xAtSpd
        AND NOT DREAM_MC_PTM_02.iq_stPTM.i_xAtSpd
        AND NOT DREAM_CAT1_PTM_01.iq_stPTM.i_xAtSpd
        AND NOT DREAM_CAT2_PTM_01.iq_stPTM.i_xAtSpd
        AND NOT DREAM_ROUGH2_PTM_01.iq_stPTM.i_xAtSpd
        AND NOT DREAM_ROUGH2_PTM_02.iq_stPTM.i_xAtSpd
    THEN (*if serial communication doesn't work and not at speed*)
        M_SetMessage('Pumps spindown-timeout, start venting');
        M_ResetTimeoutTimer();
        E_OpStep := E_OpStep.VMCAS_VENTING;
    ELSE
        ; //should we add that statemachine goes to error if the pumps didn't start spinning down?
    END_IF

    //reset vent valve postions just in case
    fRough2VFV2Position := ROUGH2_VFV_02_INITIAL_POSITION;
    fRough2VFV3Position := ROUGH2_VFV_03_INITIAL_POSITION;

E_OpStep.VMCAS_VENTING: // Venting, increase opening by X% every 2 miniutes, until at atmosphere
    DREAM_ROUGH2_VFV_02.M_SetControlMode(E_VCN.ManualControl);
    DREAM_ROUGH2_VFV_03.M_SetControlMode(E_VCN.ManualControl);

    DREAM_ROUGH2_VFV_02.M_SetReqPosition(fRough2VFV2Position);
    DREAM_ROUGH2_VFV_03.M_SetReqPosition(fRough2VFV3Position);

    IF NOT (ABS(ATM_PRESS - DREAM_DP1_GPI_01.PG.rPRESS) <= ATM_PRESS_ERR_RNG)
        AND NOT (ABS(ATM_PRESS - DREAM_MC_GPI_01.PG.rPRESS) <= ATM_PRESS_ERR_RNG)
        AND NOT (ABS(ATM_PRESS - DREAM_ROUGH2_GPI_02.PG.rPRESS) <= ATM_PRESS_ERR_RNG)
        AND NOT (ABS(ATM_PRESS - DREAM_ROUGH2_GPI_03.PG.rPRESS) <= ATM_PRESS_ERR_RNG)
    THEN
        M_RunTimeoutTimer(VENTING_CYCLE);
        M_SetMessage('Venting Started');
        //add check if serial communication is ok. If not ok we should only stick to change open position by 1% until venting completed
        IF M_TimeoutExpired() THEN
            IF NOT (DREAM_DP1_PTM_01.iq_stPTM.i_diCurSpd < 1)
                AND NOT (DREAM_DP2_PTM_01.iq_stPTM.i_diCurSpd < 1)
                AND NOT (DREAM_DP3_PTM_01.iq_stPTM.i_diCurSpd < 1)
                AND NOT (DREAM_MC_PTM_01.iq_stPTM.i_diCurSpd < 1)
                AND NOT (DREAM_MC_PTM_02.iq_stPTM.i_diCurSpd < 1)
                AND NOT (DREAM_CAT1_PTM_01.iq_stPTM.i_diCurSpd < 1)
                AND NOT (DREAM_CAT2_PTM_01.iq_stPTM.i_diCurSpd < 1)
                AND NOT (DREAM_ROUGH2_PTM_01.iq_stPTM.i_diCurSpd < 1)
                AND NOT (DREAM_ROUGH2_PTM_02.iq_stPTM.i_diCurSpd < 1)
            THEN
                IF fRough2VFV2Position < VFV_MAX_POSITION THEN
                    fRough2VFV2Position := fRough2VFV2Position + 1; // every 2 min increase open positon for 1% while pumps above 1 HZ
                ELSE
                    fRough2VFV2Position := VFV_MAX_POSITION;
                END_IF
                IF fRough2VFV3Position < VFV_MAX_POSITION THEN
                    fRough2VFV3Position := fRough2VFV3Position + 1; // every 2 min increase open positon for 1% while pumps above 1 HZ
                ELSE
                    fRough2VFV3Position := VFV_MAX_POSITION;
                END_IF

                DREAM_ROUGH2_VFV_02.M_SetReqPosition(fRough2VFV2Position);
                DREAM_ROUGH2_VFV_03.M_SetReqPosition(fRough2VFV3Position);
            ELSE
                DREAM_ROUGH2_VFV_02.M_SetReqPosition(100.0); // open venting valve to max postion when pumps reached below 1Hz
                DREAM_ROUGH2_VFV_03.M_SetReqPosition(100.0); // open venting valve to max postion when pumps reached below 1Hz
            END_IF
        END_IF
    ELSE
        M_SetMessage('Venting completed');
        M_ResetTimeoutTimer();
        E_OpStep := E_OpStep.VMCAS_FINISH;
    END_IF

E_OpStep.VMCAS_FINISH: // Finish procedure, close venting valves, reset set points for all valves, pumps etc.
    DREAM_ROUGH2_VFV_02.M_SetControlMode(E_VCN.CloseValve);
    DREAM_ROUGH2_VFV_03.M_SetControlMode(E_VCN.CloseValve);
    //reset vent valve postions for next time
    fRough2VFV2Position := ROUGH2_VFV_02_INITIAL_POSITION;
    fRough2VFV3Position := ROUGH2_VFV_03_INITIAL_POSITION;

    DREAM_ROUGH2_VRC_01.M_SetAtVacSP(VALVE_INTERLOCK_SP);
    DREAM_ROUGH2_VRC_02.M_SetAtVacSP(VALVE_INTERLOCK_SP);

    DREAM_DP1_PTM_01.M_SetBackingSP(PTM_INTERLOCK_SP);
    DREAM_DP2_PTM_01.M_SetBackingSP(PTM_INTERLOCK_SP);
    DREAM_DP3_PTM_01.M_SetBackingSP(PTM_INTERLOCK_SP);
    DREAM_MC_PTM_01.M_SetBackingSP(PTM_INTERLOCK_SP);
    DREAM_MC_PTM_02.M_SetBackingSP(PTM_INTERLOCK_SP);
    DREAM_CAT1_PTM_01.M_SetBackingSP(PTM_INTERLOCK_SP);
    DREAM_CAT2_PTM_01.M_SetBackingSP(PTM_INTERLOCK_SP);
    DREAM_ROUGH2_PTM_01.M_SetBackingSP(PTM_INTERLOCK_SP);
    DREAM_ROUGH2_PTM_02.M_SetBackingSP(PTM_INTERLOCK_SP);

    M_Finish();

ELSE
    M_FatalError('Operation is in invalid state');
END_CASE]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>